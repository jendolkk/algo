template <class T>
constexpr T power(T a, int64_t b) {
  assert(b >= 0);
  T res(1);
  for (; b; b >>= 1, a *= a) {
    if (b & 1) {
      res *= a;
    }
  }
  return res;
}

template <uint32_t md>
class modint {
 public:
  constexpr modint() : v(0) {}
  constexpr modint(int64_t t) { int64_t x = t % md; v = x < 0 ? x + md : x; }
  template <typename T> constexpr explicit operator T() { return static_cast<T>(v); }
  constexpr modint operator-() const { return modint(0) - v; }
  constexpr uint32_t operator()() const { return v; }
  constexpr uint32_t val() const { return v; }
  constexpr modint inv() const { return power(*this, md - 2); }
  constexpr modint& operator*=(const modint& b) { v = uint64_t(v) * b.v % md; return *this; }
  constexpr modint& operator+=(const modint& b) { v += b.v; if (v >= md) v -= md; return *this; }
  constexpr modint& operator-=(const modint& b) { v -= b.v; if (v >= md) v += md; return *this; }
  constexpr modint& operator/=(const modint& b) { return *this *= b.inv(); }
  constexpr friend modint operator+(modint a, const modint& b) { return a += b; }
  constexpr friend modint operator-(modint a, const modint& b) { return a -= b; }
  constexpr friend modint operator*(modint a, const modint& b) { return a *= b; }
  constexpr friend modint operator/(modint a, const modint& b) { return a /= b; }
  constexpr friend bool operator==(const modint& a, const modint& b) { return a.v == b.v; }
  constexpr friend bool operator!=(const modint& a, const modint& b) { return a.v != b.v; }
  constexpr friend bool operator<(const modint& a, const modint& b) { return a.v < b.v; }
  constexpr friend const int& abs(const modint& a) { return a(); }
  template <typename T> friend T& operator>>(T& stream, modint& a) { int64_t t; stream >> t; a = modint(t); return stream; }
  template <typename T> friend T& operator<<(T& stream, const modint& a) { return stream << a.v; }
 private:
  uint32_t v;
};

constexpr uint32_t md3 = 998244353;
constexpr uint32_t md7 = 1e9 + 7;
using Mint = modint<md>;

