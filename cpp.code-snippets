{
  "acm": {
    "prefix": "acm",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "using u32 = uint32_t;",
      "using i64 = int64_t;",
      "using u64 = uint64_t;",
      "using f64 = double;",
      "using i128 = __int128;",
      "using u128 = unsigned __int128;",
      "",
      "#ifdef LOCAL",
      "#include \"debug.h\"",
      "#else",
      "#define debug(...) ((void)0)",
      "#endif",
      "",
      "int main() {",
      "  std::ios::sync_with_stdio(false);",
      "  std::cin.tie(nullptr);",
      "",
      "",
      "",
      "}"
    ],
    "description": "acm"
  },
  "AhoCorasick": {
    "prefix": "AhoCorasick",
    "body": [
      "template <int CHARSET_SIZE = 26, int CHAR_BEG = 'a'>",
      "class AhoCorasick {",
      " public:",
      "  struct Node : std::array<int, CHARSET_SIZE> {",
      "    int fail{};",
      "    int pv{};",
      "    Node() { this->fill(0); }",
      "  };",
      "",
      "  std::vector<Node> nodes;",
      "",
      "  explicit AhoCorasick(): nodes(1) {}",
      "",
      "  template <typename T>",
      "  int add(const T& s) {",
      "    int p = 0;",
      "    for (auto c : s) {",
      "      int u = c - CHAR_BEG;",
      "      if (!nodes[p][u]) {",
      "        nodes[p][u] = nodes.size();",
      "        nodes.emplace_back();",
      "        nodes.back().pv = p;",
      "      }",
      "      p = nodes[p][u];",
      "    }",
      "    return p;",
      "  }",
      "",
      "  std::vector<int> build() {",
      "    std::vector<int> que;",
      "    for (int i = 0; i < CHARSET_SIZE; i++) {",
      "      if (nodes[0][i]) {",
      "        que.push_back(nodes[0][i]);",
      "      }",
      "    }",
      "    for (int i = 0; i < que.size(); i++) {",
      "      int u = que[i];",
      "      for (int j = 0; j < CHARSET_SIZE; j++) {",
      "        int& p = nodes[u][j];",
      "        (p ? que.push_back(p), nodes[p].fail : p) = nodes[nodes[u].fail][j];",
      "      }",
      "    }",
      "    return que;",
      "  }",
      "",
      "  Node& operator[](int p) {",
      "    return nodes[p];",
      "  }",
      "",
      "  int size() {",
      "    return nodes.size();",
      "  }",
      "};",
      ""
    ],
    "description": "AhoCorasick"
  },
  "CartesianTree": {
    "prefix": "CartesianTree",
    "body": [
      "template <typename T, class Compare = std::less<T>>",
      "class CartesianTree {",
      " public:",
      "  std::vector<int> ls, rs, sz, lb, rb;",
      "  int root = -1, n;",
      "",
      "  CartesianTree(const std::vector<T>& a, Compare comp = Compare())",
      "      : n(a.size()), ls(a.size(), -1), rs(a.size(), -1) {",
      "    assert(!a.empty());",
      "    std::vector<int> stk;",
      "    for (int i = 0; i < n; i++) {",
      "      int lst = -1;",
      "      while (!stk.empty() && comp(a[i], a[stk.back()])) {",
      "        lst = stk.back();",
      "        stk.pop_back();",
      "      }",
      "      ls[i] = lst;",
      "      if (!stk.empty()) {",
      "        rs[stk.back()] = i;",
      "      }",
      "      stk.push_back(i);",
      "    }",
      "    root = stk.front();",
      "  }",
      "",
      "  std::vector<int> build_sz() {",
      "    sz.assign(n, 1);",
      "    lb.resize(n);",
      "    rb.resize(n);",
      "    auto dfs = [&](auto self, int u) -> int {",
      "      lb[u] = rb[u] = u;",
      "      if (ls[u] != -1) {",
      "        sz[u] += self(self, ls[u]);",
      "        lb[u] = lb[ls[u]];",
      "      }",
      "      if (rs[u] != -1) {",
      "        sz[u] += self(self, rs[u]);",
      "        rb[u] = rb[rs[u]];",
      "      }",
      "      return sz[u];",
      "    };",
      "    dfs(dfs, root);",
      "    return sz;",
      "  }",
      "};",
      ""
    ],
    "description": "CartesianTree"
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "template <typename T>",
      "std::vector<T> dij(const std::vector<std::vector<std::pair<int, T>>>& g, int st) {",
      "  assert(0 <= st && st < g.size());",
      "  int n = g.size();",
      "  std::vector<T> d(n, std::numeric_limits<T>::max());",
      "  using pti = std::pair<T, int>;",
      "  std::priority_queue<pti, std::vector<pti>, std::greater<pti>> h;",
      "  h.emplace(0, st);",
      "  d[st] = 0;",
      "  while (!h.empty()) {",
      "    auto [dist, u] = h.top();",
      "    h.pop();",
      "    if (d[u] != dist) {",
      "      continue;",
      "    }",
      "    for (auto [v, cost] : g[u]) {",
      "      if (d[v] > dist + cost) {",
      "        d[v] = dist + cost;",
      "        h.emplace(d[v], v);",
      "      }",
      "    }",
      "  }",
      "  return d;",
      "}",
      ""
    ],
    "description": "dijkstra"
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "class dsu {",
      " public:",
      "  explicit dsu(int _n) : p(_n, -1) {}",
      "",
      "  int get(int x) {",
      "    return p[x] < 0 ? x : p[x] = get(p[x]);",
      "  }",
      "",
      "  bool merge(int x, int y) {",
      "    x = get(x); y = get(y);",
      "    if (x != y) {",
      "      p[x] += p[y];",
      "      p[y] = x;",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "",
      "  bool same(int x, int y) {",
      "    return get(x) == get(y);",
      "  }",
      "",
      "  int size(int x) {",
      "    return -p[get(x)];",
      "  }",
      "",
      " private:",
      "  std::vector<int> p;",
      "};",
      ""
    ],
    "description": "dsu"
  },
  "ecc": {
    "prefix": "ecc",
    "body": [
      "template <typename T>",
      "std::vector<std::vector<int>> ecc(const std::vector<std::vector<T>>& g) {",
      "  int n = g.size();",
      "  std::vector<int> pos(n, -1), stk;",
      "  std::vector<vector<int>> res;",
      "  auto dfs = [&](auto self, int u, int p) -> int {",
      "    int low = pos[u] = stk.size(), counter = 0;",
      "    stk.push_back(u);",
      "    for (const auto j : g[u]) {",
      "      int v;",
      "      if constexpr (std::is_integral_v<std::decay_t<decltype(j)>>) {",
      "        v = j;",
      "      } else {",
      "        v = std::get<0>(j);",
      "      }",
      "      if (pos[v] != -1) {",
      "        if (v != p || counter++) {",
      "          low = std::min(low, pos[v]);",
      "        }",
      "      } else {",
      "        low = std::min(low, self(self, v, u));",
      "      }",
      "    };",
      "    if (low == pos[u]) {",
      "      res.emplace_back(stk.begin() + low, stk.end());",
      "      stk.resize(low);",
      "    }",
      "    return low;",
      "  };",
      "  for (int i = 0; i < n; i++) {",
      "    if (pos[i] == -1) {",
      "      dfs(dfs, i, -1);",
      "    }",
      "  }",
      "  return res;",
      "}",
      ""
    ],
    "description": "ecc"
  },
  "exgcd": {
    "prefix": "exgcd",
    "body": [
      "template <typename T>",
      "T exgcd(T a, T b, T& x, T& y) {",
      "  if (b == 0) {",
      "    x = 1; y = 0;",
      "    return a;",
      "  }",
      "  T t = a / b;",
      "  T d = exgcd(b, a - t * b, y, x);",
      "  y -= t * x;",
      "  return d;",
      "}",
      ""
    ],
    "description": "exgcd"
  },
  "fact": {
    "prefix": "fact",
    "body": [
      "std::vector<Mint> fact{1};",
      "std::vector<Mint> inv_fact{1};",
      "",
      "Mint C(int n, int k) {",
      "  if (k < 0 || k > n) {",
      "    return 0;",
      "  }",
      "  if (fact.size() <= n) {",
      "    int m = fact.size();",
      "    int new_sz = n + n / 2 + 1;",
      "    fact.resize(new_sz);",
      "    inv_fact.resize(new_sz);",
      "    for (int i = m; i < new_sz; i++) {",
      "      fact[i] = fact[i - 1] * i;",
      "    }",
      "    inv_fact.back() = fact.back().inv();",
      "    for (int i = new_sz - 1; i > m; i--) {",
      "      inv_fact[i - 1] = inv_fact[i] * i;",
      "    }",
      "  }",
      "  return fact[n] * inv_fact[k] * inv_fact[n - k];",
      "}",
      ""
    ],
    "description": "fact"
  },
  "fenwick": {
    "prefix": "fenwick",
    "body": [
      "template <typename T>",
      "class fenwick {",
      " public:",
      "  fenwick(int _n) : n(_n), lg2(std::__lg(n)), data(_n) {}",
      "",
      "  void add(int p, T v) {",
      "    assert(0 <= p && p < n);",
      "    for (p++; p <= n; p += p & -p) {",
      "      data[p - 1] += v;",
      "    }",
      "  }",
      "",
      "  T get(int l, int r) {",
      "    assert(0 <= l && l <= r && r <= n);",
      "    return sum(r) - sum(l);",
      "  }",
      "",
      "  int max_right(T bound) {",
      "    T s{};",
      "    int bin = 0;",
      "    for (int i = 1 << lg2; i > 0; i >>= 1) {",
      "      if (bin + i <= n) {",
      "        T ns = s;",
      "        ns += data[bin + i - 1];",
      "        if (!(bound < ns)) {",
      "          s = ns;",
      "          bin += i;",
      "        }",
      "      }",
      "    }",
      "    return bin - 1;",
      "  }",
      "",
      " private:",
      "  int n, lg2;",
      "  std::vector<T> data;",
      "",
      "  T sum(int r) {",
      "    T s{};",
      "    for (; r > 0; r -= r & -r) {",
      "      s += data[r - 1];",
      "    }",
      "    return s;",
      "  }",
      "};",
      ""
    ],
    "description": "fenwick"
  },
  "fft": {
    "prefix": "fft",
    "body": [
      "namespace FFT {",
      "using db = double;",
      "",
      "constexpr db PI = std::acosl(-1);",
      "",
      "struct num {",
      "  db x = 0;",
      "  db y = 0;",
      "};",
      "num operator+(const num& a, const num& b) { return {a.x + b.x, a.y + b.y }; }",
      "num operator-(const num& a, const num& b) { return {a.x - b.x, a.y - b.y }; }",
      "num operator*(const num& a, const num& b) { return {a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x}; }",
      "",
      "int base = 1;",
      "std::vector<int> rev;",
      "std::vector<num> roots = {{0, 0}, {1, 0}};",
      "",
      "void ensure_base(int nbase) {",
      "  if (nbase <= base) {",
      "    return;",
      "  }",
      "  rev.resize(1 << nbase);",
      "  for (int i = 0; i < (1 << nbase); i++) {",
      "    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
      "  }",
      "  roots.resize(1 << nbase);",
      "  while (base < nbase) {",
      "    db angle = 2 * PI / (1 << (base + 1));",
      "//      num z(cos(angle), sin(angle));",
      "    for (int i = 1 << (base - 1); i < (1 << base); i++) {",
      "      roots[i << 1] = roots[i];",
      "//        roots[(i << 1) + 1] = roots[i] * z;",
      "      db angle_i = angle * (2 * i + 1 - (1 << base));",
      "      roots[(i << 1) + 1] = {std::cos(angle_i), std::sin(angle_i)};",
      "    }",
      "    base++;",
      "  }",
      "}",
      "",
      "void fft(std::vector<num>& a) {",
      "  int n = a.size();",
      "  int zeros = __builtin_ctz(n);",
      "  ensure_base(zeros);",
      "  int shift = base - zeros;",
      "  for (int i = 0; i < n; i++) {",
      "    if (i < (rev[i] >> shift)) {",
      "      std::swap(a[i], a[rev[i] >> shift]);",
      "    }",
      "  }",
      "  for (int k = 1; k < n; k <<= 1) {",
      "    for (int i = 0; i < n; i += k << 1) {",
      "      for (int j = 0; j < k; j++) {",
      "        num z = a[i + j + k] * roots[j + k];",
      "        a[i + j + k] = a[i + j] - z;",
      "        a[i + j] = a[i + j] + z;",
      "      }",
      "    }",
      "  }",
      "}",
      "",
      "std::vector<num> A, B;",
      "",
      "template <typename T>",
      "vector<T> mul(std::vector<T>& a, std::vector<T>& b) {",
      "  assert(!a.empty() && !b.empty());",
      "  int need = a.size() + b.size() - 1;",
      "  int nbase = 1;",
      "  while ((1 << nbase) < need) nbase++;",
      "  ensure_base(nbase);",
      "  int sz = 1 << nbase;",
      "  if (sz > int(A.size())) A.resize(sz);",
      "  if (sz > int(B.size())) B.resize(sz);",
      "  for (int i = 0; i < sz; i++) {",
      "    A[i].x = (i < int(a.size()) ? a[i] : 0);",
      "    A[i].y = 0;",
      "    B[i].x = (i < int(b.size()) ? b[i] : 0);",
      "    B[i].y = 0;",
      "  }",
      "  fft(A);",
      "  fft(B);",
      "  for (int i = 0; i < sz; i++) {",
      "    A[i] = A[i] * B[i];",
      "  }",
      "  std::reverse(A.begin() + 1, A.end());",
      "  fft(A);",
      "  std::vector<T> res(sz);",
      "  for (int i = 0; i < sz; i++) {",
      "    res[i] = std::round(A[i].x / sz);",
      "  }",
      "  res.resize(need);",
      "  return res;",
      "}",
      "} // namespace FFT",
      "using namespace FFT;",
      ""
    ],
    "description": "fft"
  },
  "gauss": {
    "prefix": "gauss",
    "body": [
      "// constexpr double eps = 1e-9;",
      "// bool isZero(double x) {",
      "//   return std::abs(x) < eps;",
      "// }",
      "",
      "// constexpr Mint eps = 1;",
      "// bool isZero(Mint x) {",
      "//   return x == 0;",
      "// }",
      "",
      "template <typename T>",
      "std::pair<int, T> gauss(std::vector<std::vector<T>>& a) {",
      "  using namespace std;",
      "  int rank = 0;",
      "  T mul = 1;",
      "  int n = a.size();",
      "  if (n == 0) {",
      "    return {rank, mul};",
      "  }",
      "  int m = a[0].size();",
      "  for (int j = 0; j < m; j++) {",
      "    int p = rank;",
      "    for (int i = p + 1; i < n; i++) {",
      "      if (abs(a[p][j]) < abs(a[i][j])) {",
      "        p = i;",
      "      }",
      "    }",
      "    if (isZero(a[p][j])) {",
      "      continue;",
      "    }",
      "    if (p != rank) {",
      "      swap(a[rank], a[p]);",
      "      mul = -mul;",
      "    }",
      "    mul *= a[rank][j];",
      "    T inv = 1 / a[rank][j];",
      "    for (int i = 0; i < n; i++) {",
      "      if (i != rank) {",
      "        T coeff = a[i][j] * inv;",
      "        for (int k = j; k < m; k++) {",
      "          a[i][k] -= a[rank][k] * coeff;",
      "        }",
      "      }",
      "    }",
      "    for (int k = m - 1; k >= j; k--) {",
      "      a[rank][k] *= inv;",
      "    }",
      "    if (j < m) {",
      "      rank++;",
      "    }",
      "    if (rank == n) {",
      "      break;",
      "    }",
      "  }",
      "  return {rank, mul};",
      "}",
      "",
      "template <typename T>",
      "T determinant(std::vector<std::vector<T>> a) {",
      "  auto [rank, mul] = gauss(a);",
      "  if (rank < a.size()) {",
      "    return 0;",
      "  } else {",
      "    for (int i = 0; i < a.size(); i++) {",
      "      mul *= a[i][i];",
      "    }",
      "    return mul;",
      "  }",
      "}",
      "",
      "template <typename T>",
      "std::vector<std::vector<T>> inverse(std::vector<std::vector<T>> a) {",
      "  int n = a.size();",
      "  for (int i = 0; i < n; i++) {",
      "    a[i].resize(2 * n);",
      "    a[i][i + n] = 1;",
      "  }",
      "  auto [rank, mul] = gauss(a);",
      "  if (rank < n) {",
      "    return {};",
      "  }",
      "  for (int i = 0; i < n; i++) {",
      "    if (isZero(a[i][i])) {",
      "      return {};",
      "    }",
      "  }",
      "  std::vector<std::vector<T>> b(n);",
      "  for (int i = 0; i < n; i++) {",
      "    b[i] = std::vector(a[i].begin() + n, a[i].end());",
      "  }",
      "  return b;",
      "}",
      ""
    ],
    "description": "gauss"
  },
  "gen": {
    "prefix": "gen",
    "body": [
      "import os",
      "import json",
      "import sys",
      "",
      "snippets = {}",
      "",
      "for subdir in os.walk('.'):",
      "  if '.git' in subdir[0]:",
      "    continue",
      "  print(subdir)",
      "  for filename in subdir[2]:",
      "    name, extension = filename.split('.')",
      "  # for name in subdir[2]:",
      "    # if '.' in name:",
      "    if extension not in (\"cpp\", \"py\"):",
      "      continue",
      "",
      "    if name in snippets:",
      "      print(f'error: duplicate snippet {name}', file=sys.stderr)",
      "      exit(0)",
      "",
      "    path = subdir[0] + '/' + filename",
      "    with open(path, 'r') as f:",
      "      snippet = {",
      "        \"prefix\": name,",
      "        \"body\": [line.rstrip() for line in f.readlines()],",
      "        \"description\": name",
      "      }",
      "      snippets[name] = snippet",
      "",
      "    print(f'generated snippet {name}', file=sys.stderr)",
      "",
      "with open('cpp.code-snippets', 'w') as f:",
      "  f.write(json.dumps(snippets, indent=2))",
      "",
      "print('done', file=sys.stderr)"
    ],
    "description": "gen"
  },
  "hash61": {
    "prefix": "hash61",
    "body": [
      "struct hash61 {",
      "  static const uint64_t md = (1LL << 61) - 1;",
      "  static uint64_t step;",
      "  static vector<uint64_t> pw;",
      "",
      "  uint64_t addmod(uint64_t a, uint64_t b) const {",
      "    a += b;",
      "    if (a >= md) a -= md;",
      "    return a;",
      "  }",
      "",
      "  uint64_t submod(uint64_t a, uint64_t b) const {",
      "    a += md - b;",
      "    if (a >= md) a -= md;",
      "    return a;",
      "  }",
      "",
      "  uint64_t mulmod(uint64_t a, uint64_t b) const {",
      "    uint64_t l1 = (uint32_t) a, h1 = a >> 32, l2 = (uint32_t) b, h2 = b >> 32;",
      "    uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;",
      "    uint64_t ret = (l & md) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;",
      "    ret = (ret & md) + (ret >> 61);",
      "    ret = (ret & md) + (ret >> 61);",
      "    return ret - 1;",
      "  }",
      "",
      "  void ensure_pw(int sz) {",
      "    int cur = (int) pw.size();",
      "    if (cur < sz) {",
      "      pw.resize(sz);",
      "      for (int i = cur; i < sz; i++) {",
      "        pw[i] = mulmod(pw[i - 1], step);",
      "      }",
      "    }",
      "  }",
      "",
      "  vector<uint64_t> pref;",
      "  int n;",
      "",
      "  template<typename T>",
      "  hash61(const T& s) {",
      "    n = (int) s.size();",
      "    ensure_pw(n + 1);",
      "    pref.resize(n + 1);",
      "    pref[0] = 1;",
      "    for (int i = 0; i < n; i++) {",
      "      pref[i + 1] = addmod(mulmod(pref[i], step), s[i]);",
      "    }",
      "  }",
      "",
      "  inline uint64_t operator()(const int from, const int to) const {",
      "    assert(0 <= from && from <= to && to <= n - 1);",
      "    return submod(pref[to + 1], mulmod(pref[from], pw[to - from + 1]));",
      "  }",
      "};",
      "",
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "uint64_t hash61::step = (md >> 2) + rng() % (md >> 1);",
      "vector<uint64_t> hash61::pw = vector<uint64_t>(1, 1);",
      ""
    ],
    "description": "hash61"
  },
  "hashmap": {
    "prefix": "hashmap",
    "body": [
      "// #include<bits/extc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "",
      "struct splitmix64_hash {",
      "\tstatic uint64_t splitmix64(uint64_t x) {",
      "\t\t// http://xorshift.di.unimi.it/splitmix64.c",
      "\t\tx += 0x9e3779b97f4a7c15;",
      "\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "\t\treturn x ^ (x >> 31);",
      "\t}",
      "",
      "\tsize_t operator()(uint64_t x) const {",
      "\t\tstatic const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
      "\t\treturn splitmix64(x + FIXED_RANDOM);",
      "\t}",
      "};",
      "",
      "template <typename K, typename V, typename Hash = splitmix64_hash>",
      "using HashMap = __gnu_pbds::gp_hash_table<K, V, Hash>;",
      "",
      "template <typename K, typename Hash = splitmix64_hash>",
      "using HashSet = HashMap<K, __gnu_pbds::null_type, Hash>;",
      ""
    ],
    "description": "hashmap"
  },
  "hf": {
    "prefix": "hf",
    "body": [
      "template <typename T>",
      "class graph {",
      " public:",
      "  struct edge {",
      "    int from;",
      "    int to;",
      "    T cost;",
      "  };",
      "",
      "  vector<edge> edges;",
      "  vector<vector<int>> g;",
      "  int n;",
      "",
      "  graph(int _n) : n(_n) {",
      "    g.resize(n);",
      "  }",
      "",
      "  virtual int add(int from, int to, T cost) = 0;",
      "};",
      "",
      "template <typename T>",
      "class forest : public graph<T> {",
      " public:",
      "  using graph<T>::edges;",
      "  using graph<T>::g;",
      "  using graph<T>::n;",
      "",
      "  forest(int _n) : graph<T>(_n) {",
      "  }",
      "",
      "  int add(int from, int to, T cost = 1) {",
      "    assert(0 <= from && from < n && 0 <= to && to < n);",
      "    int id = (int) edges.size();",
      "    assert(id < n - 1);",
      "    g[from].push_back(id);",
      "    g[to].push_back(id);",
      "    edges.push_back({from, to, cost});",
      "    return id;",
      "  }",
      "};",
      "",
      "template <typename T>",
      "class dfs_forest : public forest<T> {",
      " public:",
      "  using forest<T>::edges;",
      "  using forest<T>::g;",
      "  using forest<T>::n;",
      "",
      "  vector<int> pv;",
      "  vector<int> pe;",
      "  vector<int> order;",
      "  vector<int> pos;",
      "  vector<int> end;",
      "  vector<int> sz;",
      "  vector<int> root;",
      "  vector<int> depth;",
      "  vector<T> dist;",
      "",
      "  dfs_forest(int _n) : forest<T>(_n) {",
      "  }",
      "",
      "  void init() {",
      "    pv = vector<int>(n, -1);",
      "    pe = vector<int>(n, -1);",
      "    order.clear();",
      "    pos = vector<int>(n, -1);",
      "    end = vector<int>(n, -1);",
      "    sz = vector<int>(n, 0);",
      "    root = vector<int>(n, -1);",
      "    depth = vector<int>(n, -1);",
      "    dist = vector<T>(n);",
      "  }",
      "",
      "  void clear() {",
      "    pv.clear();",
      "    pe.clear();",
      "    order.clear();",
      "    pos.clear();",
      "    end.clear();",
      "    sz.clear();",
      "    root.clear();",
      "    depth.clear();",
      "    dist.clear();",
      "  }",
      "",
      " private:",
      "  void do_dfs(int v) {",
      "    pos[v] = (int) order.size();",
      "    order.push_back(v);",
      "    sz[v] = 1;",
      "    for (int id : g[v]) {",
      "      if (id == pe[v]) {",
      "        continue;",
      "      }",
      "      auto &e = edges[id];",
      "      int to = e.from ^ e.to ^ v;",
      "      depth[to] = depth[v] + 1;",
      "      dist[to] = dist[v] + e.cost;",
      "      pv[to] = v;",
      "      pe[to] = id;",
      "      root[to] = (root[v] != -1 ? root[v] : to);",
      "      do_dfs(to);",
      "      sz[v] += sz[to];",
      "    }",
      "    end[v] = (int) order.size() - 1;",
      "  }",
      "",
      "  void do_dfs_from(int v) {",
      "    depth[v] = 0;",
      "    dist[v] = T{};",
      "    root[v] = v;",
      "    pv[v] = pe[v] = -1;",
      "    do_dfs(v);",
      "  }",
      "",
      " public:",
      "  void dfs(int v, bool clear_order = true) {",
      "    if (pv.empty()) {",
      "      init();",
      "    } else {",
      "      if (clear_order) {",
      "        order.clear();",
      "      }",
      "    }",
      "    do_dfs_from(v);",
      "  }",
      "",
      "  void dfs_all() {",
      "    init();",
      "    for (int v = 0; v < n; v++) {",
      "      if (depth[v] == -1) {",
      "        do_dfs_from(v);",
      "      }",
      "    }",
      "    assert((int) order.size() == n);",
      "  }",
      "};",
      "",
      "template <typename T>",
      "class hld_forest : public dfs_forest<T> {",
      " public:",
      "  using dfs_forest<T>::edges;",
      "  using dfs_forest<T>::g;",
      "  using dfs_forest<T>::n;",
      "  using dfs_forest<T>::pv;",
      "  using dfs_forest<T>::sz;",
      "  using dfs_forest<T>::root;",
      "  using dfs_forest<T>::pos;",
      "  using dfs_forest<T>::end;",
      "  using dfs_forest<T>::order;",
      "  using dfs_forest<T>::depth;",
      "  using dfs_forest<T>::dfs;",
      "  using dfs_forest<T>::dfs_all;",
      "",
      "  vector<int> head;",
      "  vector<int> visited;",
      "",
      "  hld_forest(int _n) : dfs_forest<T>(_n) {",
      "    visited.resize(n);",
      "  }",
      "",
      "  void build_hld(const vector<int> &vs) {",
      "    for (int tries = 0; tries < 2; tries++) {",
      "      if (vs.empty()) {",
      "        dfs_all();",
      "      } else {",
      "        order.clear();",
      "        for (int v : vs) {",
      "          dfs(v, false);",
      "        }",
      "        assert((int) order.size() == n);",
      "      }",
      "      if (tries == 1) {",
      "        break;",
      "      }",
      "      for (int i = 0; i < n; i++) {",
      "        if (g[i].empty()) {",
      "          continue;",
      "        }",
      "        int best = -1, bid = 0;",
      "        for (int j = 0; j < (int) g[i].size(); j++) {",
      "          int id = g[i][j];",
      "          int v = edges[id].from ^ edges[id].to ^ i;",
      "          if (pv[v] != i) {",
      "            continue;",
      "          }",
      "          if (sz[v] > best) {",
      "            best = sz[v];",
      "            bid = j;",
      "          }",
      "        }",
      "        swap(g[i][0], g[i][bid]);",
      "      }",
      "    }",
      "    head.resize(n);",
      "    for (int i = 0; i < n; i++) {",
      "      head[i] = i;",
      "    }",
      "    for (int i = 0; i < n - 1; i++) {",
      "      int x = order[i];",
      "      int y = order[i + 1];",
      "      if (pv[y] == x) {",
      "        head[y] = head[x];",
      "      }",
      "    }",
      "  }",
      "",
      "  void build_hld(int v) {",
      "    build_hld(vector<int>(1, v));",
      "  }",
      "",
      "  void build_hld_all() {",
      "    build_hld(vector<int>());",
      "  }",
      "",
      "  bool apply_on_path(int x, int y, bool with_lca, function<void(int,int,bool)> f) {",
      "    // f(x, y, up): up -- whether this part of the path goes up",
      "    assert(!head.empty());",
      "    int z = lca(x, y);",
      "    if (z == -1) {",
      "      return false;",
      "    }",
      "    {",
      "      int v = x;",
      "      while (v != z) {",
      "        if (depth[head[v]] <= depth[z]) {",
      "          f(pos[z] + 1, pos[v], true);",
      "          break;",
      "        }",
      "        f(pos[head[v]], pos[v], true);",
      "        v = pv[head[v]];",
      "      }",
      "    }",
      "    if (with_lca) {",
      "      f(pos[z], pos[z], false);",
      "    }",
      "    {",
      "      int v = y;",
      "      int cnt_visited = 0;",
      "      while (v != z) {",
      "        if (depth[head[v]] <= depth[z]) {",
      "          f(pos[z] + 1, pos[v], false);",
      "          break;",
      "        }",
      "        visited[cnt_visited++] = v;",
      "        v = pv[head[v]];",
      "      }",
      "      for (int at = cnt_visited - 1; at >= 0; at--) {",
      "        v = visited[at];",
      "        f(pos[head[v]], pos[v], false);",
      "      }",
      "    }",
      "    return true;",
      "  }",
      "",
      "  inline bool anc(int x, int y) {",
      "    return (pos[x] <= pos[y] && end[y] <= end[x]);",
      "  }",
      "",
      "  inline int go_up(int x, int up) {",
      "    int target = depth[x] - up;",
      "    if (target < 0) {",
      "      return -1;",
      "    }",
      "    while (depth[head[x]] > target) {",
      "      x = pv[head[x]];",
      "    }",
      "    return order[pos[x] - depth[x] + target];",
      "  }",
      "",
      "  inline int lca(int x, int y) {",
      "    if (root[x] != root[y]) {",
      "      return -1;",
      "    }",
      "    while (head[x] != head[y]) {",
      "      if (depth[head[x]] > depth[head[y]]) {",
      "        x = pv[head[x]];",
      "      } else {",
      "        y = pv[head[y]];",
      "      }",
      "    }",
      "    return depth[x] < depth[y] ? x : y;",
      "  }",
      "};",
      ""
    ],
    "description": "hf"
  },
  "hld": {
    "prefix": "hld",
    "body": [
      "struct hld {",
      "  int n;",
      "  std::vector<int> parent, depth, sz, top, pos, end, order;",
      "  std::vector<std::vector<int>> g;",
      "",
      "  hld(int _n) : n(_n), parent(n ,-1), depth(n), sz(n),",
      "              top(n, -1), pos(n), end(n), g(n) {}",
      "",
      "  void add(int from, int to) {",
      "    assert(0 <= from && from < n && 0 <= to && to < n);",
      "    g[from].push_back(to);",
      "    g[to].push_back(from);",
      "  }",
      "",
      "  void build(int root = 0) {",
      "    for (int k = 0; k < 2; k++) {",
      "      dfs(root);",
      "      if (k) break;",
      "      for (int i = 0; i < n; i++) {",
      "        if (!g[i].empty()) {",
      "          int hs = 0, h = 0;",
      "          for (int j = 0; j < static_cast<int>(g[i].size()); j++) {",
      "            int t = g[i][j];",
      "            if (parent[t] == i && sz[t] > h) {",
      "              h = sz[t], hs = j;",
      "            }",
      "          }",
      "          std::swap(g[i][0], g[i][hs]);",
      "        }",
      "      }",
      "      order.clear();",
      "    }",
      "    for (int i = 0; i < n; i++) {",
      "      top[i] = i;",
      "    }",
      "    for (int i = 0; i < n - 1; i++) {",
      "      int x = order[i];",
      "      int y = order[i + 1];",
      "      if (parent[y] == x) {",
      "        top[y] = top[x];",
      "      }",
      "    }",
      "    assert(static_cast<int>(order.size()) == n);",
      "  }",
      "",
      "  void dfs(int u) {",
      "    pos[u] = static_cast<int>(order.size());",
      "    order.push_back(u);",
      "    sz[u] = 1;",
      "    for (int v : g[u]) {",
      "      if (v != parent[u]) {",
      "        parent[v] = u;",
      "        depth[v] = depth[u] + 1;",
      "        dfs(v);",
      "        sz[u] += sz[v];",
      "      }",
      "    }",
      "    end[u] = static_cast<int>(order.size());  // [pos, end)",
      "  }",
      "",
      "  bool anc(int u, int v) {",
      "    return pos[u] <= pos[v] && end[v] <= end[u];",
      "  }",
      "",
      "  int lca(int u, int v) {",
      "    if (anc(u, v)) return u;",
      "    if (anc(v, u)) return v;",
      "    while (top[u] != top[v]) {",
      "      if (depth[top[u]] > depth[top[v]]) u = parent[top[u]];",
      "      else v = parent[top[v]];",
      "    }",
      "    return depth[u] < depth[v] ? u : v;",
      "  }",
      "",
      "  int dist(int u, int v) {",
      "    return depth[u] + depth[v] - 2 * depth[lca(u, v)];",
      "  }",
      "",
      "  int jump(int u, int k) {",
      "    if (depth[u] < k) {",
      "      return -1;",
      "    }",
      "    int d = depth[u] - k;",
      "    while (depth[top[u]] > d) {",
      "      u = parent[top[u]];",
      "    }",
      "    return order[pos[u] - depth[u] + d];",
      "  }",
      "",
      "  auto path(int u, int v, bool with_lca) {",
      "    assert(!top.empty());",
      "    std::vector<std::tuple<int, int, bool>> from_u_to_lca;",
      "    std::vector<std::tuple<int, int, bool>> from_v_to_lca;",
      "    while (top[u] != top[v]) {",
      "      if (depth[top[u]] > depth[top[v]]) {",
      "        from_u_to_lca.emplace_back(pos[top[u]], pos[u], true);",
      "        u = parent[top[u]];",
      "      } else {",
      "        from_v_to_lca.emplace_back(pos[top[v]], pos[v], false);",
      "        v = parent[top[v]];",
      "      }",
      "    }",
      "    if (u == v) {",
      "      if (with_lca) {",
      "        from_u_to_lca.emplace_back(pos[u], pos[u], false);",
      "      }",
      "    } else if (depth[u] > depth[v]) {",
      "      from_u_to_lca.emplace_back(pos[v] + !with_lca, pos[u], true);",
      "    } else {",
      "      from_v_to_lca.emplace_back(pos[u] + !with_lca, pos[v], false);",
      "    }",
      "    from_u_to_lca.insert(from_u_to_lca.end(), from_v_to_lca.rbegin(), from_v_to_lca.rend());",
      "    return from_u_to_lca;",
      "  }",
      "};",
      ""
    ],
    "description": "hld"
  },
  "io": {
    "prefix": "io",
    "body": [
      "static struct FastInput {",
      "  static constexpr int BUF_SIZE = 1 << 20;",
      "  char buf[BUF_SIZE];",
      "  size_t chars_read = 0;",
      "  size_t buf_pos = 0;",
      "  FILE *in = stdin;",
      "  char cur = 0;",
      "",
      "  inline char get_char() {",
      "    if (buf_pos >= chars_read) {",
      "      chars_read = fread(buf, 1, BUF_SIZE, in);",
      "      buf_pos = 0;",
      "      buf[0] = (chars_read == 0 ? -1 : buf[0]);",
      "    }",
      "    return cur = buf[buf_pos++];",
      "  }",
      "",
      "  inline void tie(int) {}",
      "",
      "  inline explicit operator bool() {",
      "    return cur != -1;",
      "  }",
      "",
      "  inline static bool is_blank(char c) {",
      "    return c <= ' ';",
      "  }",
      "",
      "  inline bool skip_blanks() {",
      "    while (is_blank(cur) && cur != -1) {",
      "      get_char();",
      "    }",
      "    return cur != -1;",
      "  }",
      "",
      "  inline FastInput& operator>>(char& c) {",
      "    skip_blanks();",
      "    c = cur;",
      "    return *this;",
      "  }",
      "",
      "  inline FastInput& operator>>(string& s) {",
      "    if (skip_blanks()) {",
      "      s.clear();",
      "      do {",
      "        s += cur;",
      "      } while (!is_blank(get_char()));",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  template <typename T>",
      "  inline FastInput& read_integer(T& n) {",
      "    // unsafe, doesn't check that characters are actually digits",
      "    n = 0;",
      "    if (skip_blanks()) {",
      "      int sign = +1;",
      "      if (cur == '-') {",
      "        sign = -1;",
      "        get_char();",
      "      }",
      "      do {",
      "        n += n + (n << 3) + cur - '0';",
      "      } while (!is_blank(get_char()));",
      "      n *= sign;",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  template <typename T>",
      "  inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {",
      "    return read_integer(n);",
      "  }",
      "",
      "  #if !defined(_WIN32) || defined(_WIN64)",
      "  inline FastInput& operator>>(__int128& n) {",
      "    return read_integer(n);",
      "  }",
      "  #endif",
      "",
      "  template <typename T>",
      "  inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {",
      "    // not sure if really fast, for compatibility only",
      "    n = 0;",
      "    if (skip_blanks()) {",
      "      string s;",
      "      (*this) >> s;",
      "      sscanf(s.c_str(), \"%lf\", &n);",
      "    }",
      "    return *this;",
      "  }",
      "} fast_input;",
      "",
      "#define cin fast_input",
      "",
      "",
      "static struct FastOutput {",
      "  static constexpr int BUF_SIZE = 1 << 20;",
      "  char buf[BUF_SIZE];",
      "  size_t buf_pos = 0;",
      "  static constexpr int TMP_SIZE = 1 << 20;",
      "  char tmp[TMP_SIZE];",
      "  FILE *out = stdout;",
      "",
      "  inline void put_char(char c) {",
      "    buf[buf_pos++] = c;",
      "    if (buf_pos == BUF_SIZE) {",
      "      fwrite(buf, 1, buf_pos, out);",
      "      buf_pos = 0;",
      "    }",
      "  }",
      "",
      "  ~FastOutput() {",
      "    fwrite(buf, 1, buf_pos, out);",
      "  }",
      "",
      "  inline FastOutput& operator<<(char c) {",
      "    put_char(c);",
      "    return *this;",
      "  }",
      "",
      "  inline FastOutput& operator<<(const char* s) {",
      "    while (*s) {",
      "      put_char(*s++);",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  inline FastOutput& operator<<(const string& s) {",
      "    for (int i = 0; i < (int) s.size(); i++) {",
      "      put_char(s[i]);",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  template <typename T>",
      "  inline char* integer_to_string(T n) {",
      "    // beware of TMP_SIZE",
      "    char* p = tmp + TMP_SIZE - 1;",
      "    if (n == 0) {",
      "      *--p = '0';",
      "    } else {",
      "      bool is_negative = false;",
      "      if (n < 0) {",
      "        is_negative = true;",
      "        n = -n;",
      "      }",
      "      while (n > 0) {",
      "        *--p = (char) ('0' + n % 10);",
      "        n /= 10;",
      "      }",
      "      if (is_negative) {",
      "        *--p = '-';",
      "      }",
      "    }",
      "    return p;",
      "  }",
      "",
      "  template <typename T>",
      "  inline typename enable_if<is_integral<T>::value, char*>::type stringify(T n) {",
      "    return integer_to_string(n);",
      "  }",
      "",
      "  #if !defined(_WIN32) || defined(_WIN64)",
      "  inline char* stringify(__int128 n) {",
      "    return integer_to_string(n);",
      "  }",
      "  #endif",
      "",
      "  template <typename T>",
      "  inline typename enable_if<is_floating_point<T>::value, char*>::type stringify(T n) {",
      "    sprintf(tmp, \"%.17f\", n);",
      "    return tmp;",
      "  }",
      "",
      "  template <typename T>",
      "  inline FastOutput& operator<<(const T& n) {",
      "    auto p = stringify(n);",
      "    for (; *p != 0; p++) {",
      "      put_char(*p);",
      "    }",
      "    return *this;",
      "  }",
      "} fast_output;",
      "",
      "#define cout fast_output",
      ""
    ],
    "description": "io"
  },
  "kmp": {
    "prefix": "kmp",
    "body": [
      "template <typename T>",
      "std::vector<int> border(const T &s) {",
      "  int n = static_cast<int>(s.size());",
      "  std::vector<int> p(n);",
      "  for (int i = 1, j = 0; i < n; i++) {",
      "    while (j > 0 && s[i] != s[j]) j = p[j - 1];",
      "    if (s[i] == s[j]) j++;",
      "    p[i] = j;",
      "  }",
      "  return p;",
      "}",
      "",
      "template <typename T>",
      "std::vector<int> search(const T& str, const T& pattern) {",
      "  int n = static_cast<int>(str.size()), m = static_cast<int>(pattern.size());",
      "  auto p = border(pattern);",
      "  std::vector<int> res;",
      "  for (int i = 0, j = 0; i < n; i++) {",
      "    while (j > 0 && (j == m || str[i] != pattern[j])) j = p[j - 1];",
      "    if (str[i] == pattern[j]) j++;",
      "    if (j == m) res.push_back(i - m + 1);",
      "  }",
      "  return res;",
      "}",
      ""
    ],
    "description": "kmp"
  },
  "lis": {
    "prefix": "lis",
    "body": [
      "template<typename T>",
      "int lis(const std::vector<T>& a) {",
      "  std::vector<T> u;",
      "  for (const T& x : a) {",
      "    auto it = std::lower_bound(u.begin(), u.end(), x);",
      "    if (it == u.end()) {",
      "      u.push_back(x);",
      "    } else {",
      "      *it = x;",
      "    }",
      "  }",
      "  return int(u.size());",
      "}",
      ""
    ],
    "description": "lis"
  },
  "lucas": {
    "prefix": "lucas",
    "body": [
      "Mint lucas(int64_t n, int64_t k) {",
      "  Mint ans = 1;",
      "  while (n > 0) {",
      "    ans *= C(n % md, k % md);",
      "    n /= md;",
      "    k /= md;",
      "  }",
      "  return ans;",
      "}",
      ""
    ],
    "description": "lucas"
  },
  "matching": {
    "prefix": "matching",
    "body": [
      "class matching {",
      "public:",
      "  vector<vector<int>> g;",
      "  vector<int> pa;",
      "  vector<int> pb;",
      "  vector<int> was;",
      "  int n, m;",
      "  int res;",
      "  int iter;",
      "",
      "  matching(int _n, int _m) : n(_n), m(_m) {",
      "    assert(0 <= n && 0 <= m);",
      "    pa = vector<int>(n, -1);",
      "    pb = vector<int>(m, -1);",
      "    was = vector<int>(n, 0);",
      "    g.resize(n);",
      "    res = 0;",
      "    iter = 0;",
      "  }",
      "",
      "  void add(int from, int to) {",
      "    assert(0 <= from && from < n && 0 <= to && to < m);",
      "    g[from].push_back(to);",
      "  }",
      "",
      "  bool dfs(int v) {",
      "    was[v] = iter;",
      "    for (int u : g[v]) {",
      "      if (pb[u] == -1) {",
      "        pa[v] = u;",
      "        pb[u] = v;",
      "        return true;",
      "      }",
      "    }",
      "    for (int u : g[v]) {",
      "      if (was[pb[u]] != iter && dfs(pb[u])) {",
      "        pa[v] = u;",
      "        pb[u] = v;",
      "        return true;",
      "      }",
      "    }",
      "    return false;",
      "  }",
      "",
      "  int solve() {",
      "    while (true) {",
      "      iter++;",
      "      int add = 0;",
      "      for (int i = 0; i < n; i++) {",
      "        if (pa[i] == -1 && dfs(i)) {",
      "          add++;",
      "        }",
      "      }",
      "      if (add == 0) {",
      "        break;",
      "      }",
      "      res += add;",
      "    }",
      "    return res;",
      "  }",
      "",
      "  int run_one(int v) {",
      "    if (pa[v] != -1) {",
      "      return 0;",
      "    }",
      "    iter++;",
      "    return (int) dfs(v);",
      "  }",
      "};",
      ""
    ],
    "description": "matching"
  },
  "matrix": {
    "prefix": "matrix",
    "body": [
      "template <typename T>",
      "using Matrix = std::vector<std::vector<T>>;",
      "",
      "template <typename T>",
      "Matrix<T> operator*(const Matrix<T>& a, const Matrix<T>& b) {",
      "  if (a.empty() || b.empty()) {",
      "    return {};",
      "  }",
      "  int n = a.size(), m = b[0].size();",
      "  std::vector res(n, std::vector<T>(m));",
      "  for (int i = 0; i < n; i++) {",
      "    for (int j = 0; j < m; j++) {",
      "      for (int k = 0; k < b.size(); k++) {",
      "        res[i][j] += a[i][k] * b[k][j];",
      "      }",
      "    }",
      "  }",
      "  return res;",
      "}",
      "",
      "template <typename T>",
      "Matrix<T>& operator*=(Matrix<T>& a, const Matrix<T>& b) {",
      "  return a = a * b;",
      "}",
      "",
      "template <typename T>",
      "Matrix<T> power(Matrix<T> a, int64_t b) {",
      "  assert(b >= 0 && a.size() == a[0].size());",
      "  int n = a.size();",
      "  std::vector res(n, std::vector<T>(n));",
      "  for (int i = 0; i < n; i++) {",
      "    res[i][i] = 1;",
      "  }",
      "  for (; b; b >>= 1, a *= a) {",
      "    if (b & 1) {",
      "      res *= a;",
      "    }",
      "  }",
      "  return res;",
      "}",
      ""
    ],
    "description": "matrix"
  },
  "maxflow": {
    "prefix": "maxflow",
    "body": [
      "",
      "template <typename T>",
      "struct maxflow {",
      "  static constexpr T eps = (T) 1e-9;",
      "",
      "  struct edge {",
      "    int from;",
      "    int to;",
      "    T c;",
      "    T f;",
      "    edge(int _from, int _to, T _c, T _f): from(_from), to(_to), c(_c), f(_f) {}",
      "  };",
      "",
      "  int n, s, t;",
      "  std::vector<edge> edges;",
      "  std::vector<std::vector<int>> g;",
      "  std::vector<int> d, cur, q;",
      "  T flow = 0;",
      "",
      "  maxflow() {}",
      "",
      "  maxflow(int _n, int _s, int _t) {",
      "    init(_n, _s, _t);",
      "  }",
      "",
      "  void init() {",
      "    d.resize(n);",
      "    q.resize(n);",
      "    cur.resize(n);",
      "    edges.clear();",
      "    g.assign(n, {});",
      "  }",
      "",
      "  void init(int _n, int _s, int _t) {",
      "    n = _n, s = _s, t = _t;",
      "    init();",
      "  }",
      "",
      "  void add(int u, int v, T forward, T backward) {",
      "    g[u].push_back((int) edges.size());",
      "    edges.emplace_back(u, v, forward, 0);",
      "    g[v].push_back((int) edges.size());",
      "    edges.emplace_back(v, u, backward, 0);",
      "  }",
      "",
      "  bool bfs() {",
      "    int hh = 0, tt = 0;",
      "    q[tt++] = s;",
      "    std::fill(d.begin(), d.end(), -1);",
      "    std::fill(cur.begin(), cur.end(), 0);",
      "    d[s] = 0;",
      "    while (hh < tt) {",
      "      int ver = q[hh++];",
      "      for (int id : g[ver]) {",
      "        auto [from, to, c, f] = edges[id];",
      "        if (d[to] == -1 && c - f > eps) {",
      "          d[to] = d[ver] + 1;",
      "          if (to == t) return true;",
      "          q[tt++] = to;",
      "        }",
      "      }",
      "    }",
      "    return false;",
      "  }",
      "",
      "  T dfs(int u, T limit) {",
      "    if (u == t) return limit;",
      "    T flow {};",
      "    for (int i = cur[u]; i < g[u].size() && flow < limit; cur[u] = i++) {",
      "      auto &[from, to, c, f] = edges[g[u][i]];",
      "      if (d[to] == d[u] + 1 && c - f > eps) {",
      "        T temp = dfs(to, std::min(c - f, limit - flow));",
      "        f += temp, edges[g[u][i] ^ 1].f -= temp, flow += temp;",
      "        if (temp <= eps) d[to] = -1;",
      "      }",
      "    }",
      "    return flow;",
      "  }",
      "",
      "  T mf() {",
      "    while (bfs()) {",
      "      flow += dfs(s, std::numeric_limits<T>::max());",
      "    }",
      "    return flow;",
      "  }",
      "",
      "  std::vector<int> mc() {",
      "    mf();",
      "    std::vector<bool> ret(n);",
      "    for (int i = 0; i < n; i++) {",
      "      ret[i] = (d[i] != -1);",
      "    }",
      "    return ret;",
      "  }",
      "};",
      ""
    ],
    "description": "maxflow"
  },
  "mcmf": {
    "prefix": "mcmf",
    "body": [
      "template <typename T, typename U>",
      "struct mcmf {",
      "  static constexpr T eps = (T) 1e-9;",
      "",
      "  struct edge {",
      "    int from;",
      "    int to;",
      "    T c;",
      "    T f;",
      "    U cost;",
      "    edge(int _from, int _to, T _c, T _f, U _cost):",
      "      from(_from), to(_to), c(_c), f(_f), cost(_cost) {}",
      "  };",
      "",
      "  int n, s, t;",
      "  std::vector<edge> edges;",
      "  std::vector<std::vector<int>> g;",
      "  std::vector<int> q, pe;",
      "  std::vector<bool> in_queue;",
      "  std::vector<U> dist;",
      "  T flow = 0;",
      "  U cost = 0;",
      "",
      "  mcmf() {}",
      "",
      "  mcmf(int _n, int _s, int _t) {",
      "    init(_n, _s, _t);",
      "  }",
      "",
      "  void init() {",
      "    in_queue.resize(n);",
      "    dist.resize(n);",
      "    pe.resize(n);",
      "    edges.clear();",
      "    g.assign(n, {});",
      "  }",
      "",
      "  void init(int _n, int _s, int _t) {",
      "    n = _n, s = _s, t = _t;",
      "    init();",
      "  }",
      "",
      "  void add(int u, int v, T forward, T backward, U cost) {",
      "    g[u].push_back((int) edges.size());",
      "    edges.emplace_back(u, v, forward, 0, cost);",
      "    g[v].push_back((int) edges.size());",
      "    edges.emplace_back(v, u, backward, 0, -cost);",
      "  }",
      "",
      "  bool spfa() {",
      "    std::fill(dist.begin(), dist.end(), std::numeric_limits<U>::max());",
      "    int hh = 0, tt = 1;",
      "    q.clear();",
      "    q.push_back(s);",
      "    in_queue[s] = true;",
      "    dist[s] = 0;",
      "    bool res = false;",
      "    while (hh < tt) {",
      "      int u = q[hh++];",
      "      if (u == t) {",
      "        res = true;",
      "      }",
      "      in_queue[u] = false;",
      "      for (int id : g[u]) {",
      "        const auto& e = edges[id];",
      "        if (e.c - e.f > eps && dist[e.to] > dist[u] + e.cost) {",
      "          dist[e.to] = dist[u] + e.cost;",
      "          pe[e.to] = id;",
      "          if (!in_queue[e.to]) {",
      "            q.push_back(e.to);",
      "            tt++;",
      "            in_queue[e.to] = true;",
      "          }",
      "        }",
      "      }",
      "    }",
      "    if (!res) return res;",
      "    T push = std::numeric_limits<T>::max();",
      "    int v = t;",
      "    while (v != s) {",
      "      const edge& e = edges[pe[v]];",
      "      push = std::min(push, e.c - e.f);",
      "      v = e.from;",
      "    }",
      "    v = t;",
      "    while (v != s) {",
      "      edge& e = edges[pe[v]];",
      "      e.f += push;",
      "      edge& back = edges[pe[v] ^ 1];",
      "      back.f -= push;",
      "      v = e.from;",
      "    }",
      "    flow += push;",
      "    cost += push * dist[t];",
      "    return res;",
      "  }",
      "",
      "  std::pair<T, U> run() {",
      "    while (spfa());",
      "    return {flow, cost};",
      "  }",
      "};",
      ""
    ],
    "description": "mcmf"
  },
  "mint": {
    "prefix": "mint",
    "body": [
      "template <typename T>",
      "T inverse(T a, T m) {",
      "  T u = 0, v = 1;",
      "  while (a != 0) {",
      "    T t = m / a;",
      "    m -= t * a; swap(a, m);",
      "    u -= t * v; swap(u, v);",
      "  }",
      "  assert(m == 1);",
      "  return u;",
      "}",
      "",
      "template <typename T>",
      "class Modular {",
      " public:",
      "  using Type = typename decay<decltype(T::value)>::type;",
      "",
      "  constexpr Modular() : value() {}",
      "  template <typename U>",
      "  Modular(const U& x) {",
      "    value = normalize(x);",
      "  }",
      "",
      "  template <typename U>",
      "  static Type normalize(const U& x) {",
      "    Type v;",
      "    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);",
      "    else v = static_cast<Type>(x % mod());",
      "    if (v < 0) v += mod();",
      "    return v;",
      "  }",
      "",
      "  const Type& operator()() const { return value; }",
      "  template <typename U>",
      "  explicit operator U() const { return static_cast<U>(value); }",
      "  constexpr static Type mod() { return T::value; }",
      "",
      "  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }",
      "  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }",
      "  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }",
      "  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }",
      "  Modular& operator++() { return *this += 1; }",
      "  Modular& operator--() { return *this -= 1; }",
      "  Modular operator++(int) { Modular result(*this); *this += 1; return result; }",
      "  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }",
      "  Modular operator-() const { return Modular(-value); }",
      "",
      "  template <typename U = T>",
      "  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {",
      "#ifdef _WIN32",
      "    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
      "    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
      "    asm(",
      "      \"divl %4; \\n\\t\"",
      "      : \"=a\" (d), \"=d\" (m)",
      "      : \"d\" (xh), \"a\" (xl), \"r\" (mod())",
      "    );",
      "    value = m;",
      "#else",
      "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
      "#endif",
      "    return *this;",
      "  }",
      "  template <typename U = T>",
      "  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {",
      "    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
      "    value = normalize(value * rhs.value - q * mod());",
      "    return *this;",
      "  }",
      "  template <typename U = T>",
      "  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {",
      "    value = normalize(value * rhs.value);",
      "    return *this;",
      "  }",
      "",
      "  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }",
      "",
      "  friend const Type& abs(const Modular& x) { return x.value; }",
      "",
      "  template <typename U>",
      "  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);",
      "",
      "  template <typename U>",
      "  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);",
      "",
      "  template <typename V, typename U>",
      "  friend V& operator>>(V& stream, Modular<U>& number);",
      "",
      " private:",
      "  Type value;",
      "};",
      "",
      "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }",
      "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }",
      "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }",
      "",
      "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }",
      "",
      "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
      "",
      "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
      "",
      "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
      "",
      "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
      "",
      "template<typename T, typename U>",
      "Modular<T> power(const Modular<T>& a, const U& b) {",
      "  assert(b >= 0);",
      "  Modular<T> x = a, res = 1;",
      "  U p = b;",
      "  while (p > 0) {",
      "    if (p & 1) res *= x;",
      "    x *= x;",
      "    p >>= 1;",
      "  }",
      "  return res;",
      "}",
      "",
      "template <typename T>",
      "bool IsZero(const Modular<T>& number) {",
      "  return number() == 0;",
      "}",
      "",
      "template <typename T>",
      "string to_string(const Modular<T>& number) {",
      "  return to_string(number());",
      "}",
      "",
      "// U == std::ostream? but done this way because of fastoutput",
      "template <typename U, typename T>",
      "U& operator<<(U& stream, const Modular<T>& number) {",
      "  return stream << number();",
      "}",
      "",
      "// U == std::istream? but done this way because of fastinput",
      "template <typename U, typename T>",
      "U& operator>>(U& stream, Modular<T>& number) {",
      "  typename common_type<typename Modular<T>::Type, long long>::type x;",
      "  stream >> x;",
      "  number.value = Modular<T>::normalize(x);",
      "  return stream;",
      "}",
      "",
      "/*",
      "using ModType = int;",
      "",
      "struct VarMod { static ModType value; };",
      "ModType VarMod::value;",
      "ModType& md = VarMod::value;",
      "using Mint = Modular<VarMod>;",
      "*/",
      "",
      "constexpr int md = 998244353;",
      "using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
      "",
      "/*vector<Mint> fact(1, 1);",
      "vector<Mint> inv_fact(1, 1);",
      "",
      "Mint C(int n, int k) {",
      "  if (k < 0 || k > n) {",
      "    return 0;",
      "  }",
      "  while ((int) fact.size() < n + 1) {",
      "    fact.push_back(fact.back() * (int) fact.size());",
      "    inv_fact.push_back(1 / fact.back());",
      "  }",
      "  return fact[n] * inv_fact[k] * inv_fact[n - k];",
      "}*/",
      ""
    ],
    "description": "mint"
  },
  "modint": {
    "prefix": "modint",
    "body": [
      "template <class T>",
      "constexpr T power(T a, int64_t b) {",
      "  assert(b >= 0);",
      "  T res(1);",
      "  for (; b; b >>= 1, a *= a) {",
      "    if (b & 1) {",
      "      res *= a;",
      "    }",
      "  }",
      "  return res;",
      "}",
      "",
      "template <auto md>",
      "class modint {",
      " public:",
      "  using type = std::decay_t<decltype(md)>;",
      "  static_assert(std::is_integral_v<type>);",
      "  constexpr modint() : v(0) {}",
      "  constexpr modint(int64_t t) { int64_t x = t % md; v = x < 0 ? x + md : x; }",
      "  template <typename T> constexpr explicit operator T() { return static_cast<T>(v); }",
      "  constexpr modint operator-() const { return modint(0) - v; }",
      "  constexpr type operator()() const { return v; }",
      "  constexpr type val() const { return v; }",
      "  constexpr modint inv() const { return power(*this, md - 2); }",
      "  constexpr modint& operator*=(const modint& b) { v = uint64_t(v) * b.v % md; return *this; }",
      "  constexpr modint& operator+=(const modint& b) { v += b.v; if (v >= md) v -= md; return *this; }",
      "  constexpr modint& operator-=(const modint& b) { v -= b.v; if (v >= md) v += md; return *this; }",
      "  constexpr modint& operator/=(const modint& b) { return *this *= b.inv(); }",
      "  constexpr friend modint operator+(modint a, const modint& b) { return a += b; }",
      "  constexpr friend modint operator-(modint a, const modint& b) { return a -= b; }",
      "  constexpr friend modint operator*(modint a, const modint& b) { return a *= b; }",
      "  constexpr friend modint operator/(modint a, const modint& b) { return a /= b; }",
      "  constexpr friend bool operator==(const modint& a, const modint& b) { return a.v == b.v; }",
      "  constexpr friend bool operator!=(const modint& a, const modint& b) { return a.v != b.v; }",
      "  constexpr friend bool operator<(const modint& a, const modint& b) { return a.v < b.v; }",
      "  constexpr friend const int& abs(const modint& a) { return a(); }",
      "  template <typename T> friend T& operator>>(T& stream, modint& a) { int64_t t; stream >> t; a = modint(t); return stream; }",
      "  template <typename T> friend T& operator<<(T& stream, const modint& a) { return stream << a.v; }",
      " private:",
      "  type v;",
      "};",
      "",
      "constexpr uint32_t md3 = 998244353;",
      "constexpr uint32_t md7 = 1e9 + 7;",
      "using Mint = modint<md>;",
      ""
    ],
    "description": "modint"
  },
  "ntt": {
    "prefix": "ntt",
    "body": [
      "namespace NTT {",
      "",
      "int max_base = 0, base = 0;",
      "Mint root;",
      "std::vector<int> rev;",
      "std::vector<Mint> roots;",
      "",
      "void init() {",
      "  auto tmp = md - 1;",
      "  max_base = 0;",
      "  while (tmp % 2 == 0) {",
      "    tmp /= 2;",
      "    max_base++;",
      "  }",
      "  root = 2;",
      "  while (power(root, (md - 1) >> 1) == 1) {",
      "    root++;",
      "  }",
      "  assert(power(root, md - 1) == 1);",
      "  root = power(root, (md - 1) >> max_base);",
      "  base = 1;",
      "  rev = {0, 1};",
      "  roots = {0, 1};",
      "}",
      "",
      "void ensure_base(int nbase) {",
      "  if (roots.empty()) {",
      "    init();",
      "  }",
      "  if (nbase <= base) {",
      "    return;",
      "  }",
      "  assert(nbase <= max_base);",
      "  rev.resize(1 << nbase);",
      "  for (int i = 0; i < (1 << nbase); i++) {",
      "    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
      "  }",
      "  roots.resize(1 << nbase);",
      "  while (base < nbase) {",
      "    Mint z = power(root, 1 << (max_base - 1 - base));",
      "    for (int i = 1 << (base - 1); i < (1 << base); i++) {",
      "      roots[i << 1] = roots[i];",
      "      roots[(i << 1) + 1] = roots[i] * z;",
      "    }",
      "    base++;",
      "  }",
      "}",
      "",
      "void fft(std::vector<Mint>& a) {",
      "  int n = a.size();",
      "  int zeros = __builtin_ctz(n);",
      "  ensure_base(zeros);",
      "  int shift = base - zeros;",
      "  for (int i = 0; i < n; i++) {",
      "    if (i < (rev[i] >> shift)) {",
      "      std::swap(a[i], a[rev[i] >> shift]);",
      "    }",
      "  }",
      "  for (int k = 1; k < n; k <<= 1) {",
      "    for (int i = 0; i < n; i += k << 1) {",
      "      for (int j = 0; j < k; j++) {",
      "        Mint z = a[i + j + k] * roots[j + k];",
      "        a[i + j + k] = a[i + j] - z;",
      "        a[i + j] = a[i + j] + z;",
      "      }",
      "    }",
      "  }",
      "}",
      "",
      "std::vector<Mint> mul(std::vector<Mint> a, std::vector<Mint> b) {",
      "  int need = (int) a.size() + (int) b.size() - 1;",
      "  int nbase = 0;",
      "  while ((1 << nbase) < need) nbase++;",
      "  ensure_base(nbase);",
      "  int sz = 1 << nbase;",
      "  bool eq = (a == b);",
      "  a.resize(sz);",
      "  b.resize(sz);",
      "  fft(a);",
      "  if (eq) b = a; else fft(b);",
      "  Mint inv = Mint(sz).inv();",
      "  for (int i = 0; i < sz; i++) {",
      "    a[i] *= b[i] * inv;",
      "  }",
      "  std::reverse(a.begin() + 1, a.end());",
      "  fft(a);",
      "  a.resize(need);",
      "  return a;",
      "}",
      "} // namespace NTT",
      "using namespace NTT;",
      ""
    ],
    "description": "ntt"
  },
  "pbds": {
    "prefix": "pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "template <typename T>",
      "using sset =",
      "  __gnu_pbds::tree<T, __gnu_pbds::null_type, std::less<T>,",
      "  __gnu_pbds::rb_tree_tag,",
      "  __gnu_pbds::tree_order_statistics_node_update>;",
      ""
    ],
    "description": "pbds"
  },
  "phi": {
    "prefix": "phi",
    "body": [
      "std::vector<int> least, primes, phi;",
      "void sieve(int n) {",
      "  least.assign(n + 1, 0);",
      "  primes.clear();",
      "  phi.assign(n + 1, 0);",
      "  phi[1] = 1;",
      "  for (int i = 2; i <= n; i++) {",
      "    if (least[i] == 0) {",
      "      least[i] = i;",
      "      primes.push_back(i);",
      "      phi[i] = i - 1;",
      "    }",
      "    for (auto p : primes) {",
      "      if (i * p > n) break;",
      "      least[i * p] = p;",
      "      if (p == least[i]) {",
      "        phi[i * p] = phi[i] * p;",
      "        break;",
      "      }",
      "      phi[i * p] = phi[i] * (p - 1);",
      "    }",
      "  }",
      "}",
      ""
    ],
    "description": "phi"
  },
  "poly": {
    "prefix": "poly",
    "body": [
      "template <typename T>",
      "std::vector<T>& operator+=(std::vector<T>& a, const std::vector<T>& b) {",
      "  if (a.size() < b.size()) {",
      "    a.resize(b.size());",
      "  }",
      "  for (int i = 0; i < b.size(); i++) {",
      "    a[i] += b[i];",
      "  }",
      "  return a;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> operator+(const std::vector<T>& a, const std::vector<T>& b) {",
      "  std::vector<T> c = a;",
      "  return c += b;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T>& operator-=(std::vector<T>& a, const std::vector<T>& b) {",
      "  if (a.size() < b.size()) {",
      "    a.resize(b.size());",
      "  }",
      "  for (int i = 0; i < b.size(); i++) {",
      "    a[i] -= b[i];",
      "  }",
      "  return a;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> operator-(const std::vector<T>& a, const std::vector<T>& b) {",
      "  std::vector<T> c = a;",
      "  return c -= b;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> operator-(const std::vector<T>& a) {",
      "  std::vector<T> c = a;",
      "  for (auto& x : c) {",
      "    x = -x;",
      "  }",
      "  return c;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> operator*(const std::vector<T>& a, const std::vector<T>& b) {",
      "  if (a.empty() || b.empty()) {",
      "    return {};",
      "  }",
      "  int n = a.size(), m = b.size();",
      "  if (n < 150 || m < 150) {",
      "    std::vector<T> c(n + m - 1, 0);",
      "    for (int i = 0; i < n; i++) {",
      "      for (int j = 0; j < m; j++) {",
      "        c[i + j] += a[i] * b[j];",
      "      }",
      "    }",
      "    return c;",
      "  }",
      "  return mul(a, b);",
      "}",
      "",
      "template <typename T>",
      "std::vector<T>& operator*=(std::vector<T>& a, const std::vector<T>& b) {",
      "  return a = a * b;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> inverse(const std::vector<T>& a) {",
      "  assert(!a.empty());",
      "  std::vector<T> b = {1 / a[0]};",
      "  int n = a.size(), s = 1;",
      "  while (s < n) {",
      "    s *= 2;",
      "    std::vector<T> t = b * b * std::vector<T>(a.begin(), a.begin() + std::min(n, s));",
      "    b.resize(s);",
      "    for (int i = s / 2; i < std::min(int(t.size()), s); i++) {",
      "      b[i] = -t[i];",
      "    }",
      "  }",
      "  b.resize(n);",
      "  return b;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T>& operator/=(std::vector<T>& a, const std::vector<T>& b) {",
      "  int n = a.size(), m = b.size();",
      "  if (n < m) {",
      "    a.clear();",
      "  } else {",
      "    std::vector<T> d = b;",
      "    std::reverse(a.begin(), a.end());",
      "    std::reverse(d.begin(), d.end());",
      "    d.resize(n - m + 1);",
      "    a *= inverse(d);",
      "    a.erase(a.begin() + n - m + 1, a.end());",
      "    std::reverse(a.begin(), a.end());",
      "  }",
      "  return a;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> operator/(const std::vector<T>& a, const std::vector<T>& b) {",
      "  std::vector<T> c = a;",
      "  return c /= b;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T>& operator%=(std::vector<T>& a, const std::vector<T>& b) {",
      "  int n = a.size(), m = b.size();",
      "  if (n >= m) {",
      "    std::vector<T> c = (a / b) * b;",
      "    a.resize(m - 1);",
      "    for (int i = 0; i < m - 1; i++) {",
      "      a[i] -= c[i];",
      "    }",
      "  }",
      "  return a;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> operator%(const std::vector<T>& a, const std::vector<T>& b) {",
      "  std::vector<T> c = a;",
      "  return c %= b;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> derivative(const std::vector<T>& a) {",
      "  std::vector<T> c = a;",
      "  for (int i = 0; i < c.size(); i++) {",
      "    c[i] *= i;",
      "  }",
      "  if (!c.empty()) {",
      "    c.erase(c.begin());",
      "  }",
      "  return c;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> primitive(const std::vector<T>& a) {",
      "  std::vector<T> c = a;",
      "  c.insert(c.begin(), 0);",
      "  for (int i = 1; i < c.size(); i++) {",
      "    c[i] /= i;",
      "  }",
      "  return c;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> logarithm(const std::vector<T>& a) {",
      "  assert(!a.empty() && a[0] == 1);",
      "  std::vector<T> b = primitive(derivative(a) * inverse(a));",
      "  b.resize(a.size());",
      "  return b;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> exponent(const std::vector<T>& a) {",
      "  assert(!a.empty() && a[0] == 0);",
      "  int n = a.size(), s = 1;",
      "  std::vector<T> b{1};",
      "  while (s < n) {",
      "    s *= 2;",
      "    std::vector<T> x(a.begin(), a.begin() + std::min(n, s));",
      "    x[0] += 1;",
      "    std::vector<T> old_b = b;",
      "    b.resize(s);",
      "    x -= logarithm(b);",
      "    x *= old_b;",
      "    for (int i = s / 2; i < std::min(x.size(), b.size()); i++) {",
      "      b[i] = x[i];",
      "    }",
      "  }",
      "  b.resize(n);",
      "  return b;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> sqrt(const std::vector<T>& a) {",
      "  assert(!a.empty() && a[0] == 1);",
      "  int n = a.size(), s = 1;",
      "  std::vector<T> b {1};",
      "  T inv2 = 1 / static_cast<T>(2);",
      "  while (s < n) {",
      "    s *= 2;",
      "    b.resize(s);",
      "    std::vector<T> x = std::vector<T>(a.begin(), a.begin() + std::min(n, s)) * inverse(b);",
      "    for (int i = s / 2; i < std::min(n, s); i++) {",
      "      b[i] = x[i] * inv2;",
      "    }",
      "  }",
      "  b.resize(n);",
      "  return b;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> multiply(const std::vector<std::vector<T>>& a) {",
      "  if (a.empty()) {",
      "    return {0};",
      "  }",
      "  std::function<std::vector<T>(int, int)> mult = [&](int l, int r) {",
      "    if (l == r) {",
      "      return a[l];",
      "    }",
      "    int y = (l + r) >> 1;",
      "    return mult(l, y) * mult(y + 1, r);",
      "  };",
      "  return mult(0, (int) a.size() - 1);",
      "}",
      "",
      "template <typename T>",
      "T evaluate(const std::vector<T>& a, const T& x) {",
      "  T res = 0;",
      "  for (int i = int(a.size()) - 1; i >= 0; i--) {",
      "    res = res * x + a[i];",
      "  }",
      "  return res;",
      "}",
      "",
      "template <typename T>",
      "std::vector<T> power(const std::vector<T>& a, int64_t k) {",
      "  int n = a.size();",
      "  if (k == 0) {",
      "    std::vector<T> res(n, 0);",
      "    res[0] = 1;",
      "    return res;",
      "  }",
      "  int s = 0;",
      "  while (s < n && a[s] == 0) {",
      "    s++;",
      "  }",
      "  if (s == n || s >= (n + k - 1) / k) {",
      "    return std::vector<T>(n, 0);",
      "  }",
      "  std::vector<T> b(a.begin() + s, a.end());",
      "  b.resize(n);",
      "  Mint inv = b[0].inv();",
      "  for (int i = 0; i < n - s; i++) {",
      "    b[i] *= inv;",
      "  }",
      "  b = logarithm(b);",
      "  for (int i = 0; i < n; i++) {",
      "    b[i] *= k;",
      "  }",
      "  b = exponent(b);",
      "  inv = power(inv.inv(), k);",
      "  for (int i = 0; i < n; i++) {",
      "    b[i] *= inv;",
      "  }",
      "  std::vector<T> res(s * k, 0);",
      "  b.resize(n - s * k);",
      "  for (int i = s * k; i < n; i++) {",
      "    res.push_back(b[i]);",
      "  }",
      "  return res;",
      "}",
      "// to be continued..",
      ""
    ],
    "description": "poly"
  },
  "pragma": {
    "prefix": "pragma",
    "body": [
      "#pragma GCC optimize(\"O3,unroll-loops\")",
      "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
      ""
    ],
    "description": "pragma"
  },
  "pysys": {
    "prefix": "pysys",
    "body": [
      "import sys",
      "import math",
      "from collections import Counter, deque, defaultdict",
      "from bisect import bisect_left, bisect_right",
      "from heapq import heappush, heappop, heappushpop, heapify, heapreplace",
      "from itertools import accumulate",
      "from copy import deepcopy",
      "import random",
      "from functools import cache",
      "from sortedcontainers import SortedList",
      "sys.set_int_max_str_digits(int(1e7))",
      "sys.setrecursionlimit(int(1e7))",
      "",
      "input = lambda: sys.stdin.readline().strip()",
      "",
      "def read():",
      "  return list(map(int, input().split()))",
      "def readfile(f):",
      "  return list(map(int, f.readline().split()))",
      ""
    ],
    "description": "pysys"
  },
  "recsegtree": {
    "prefix": "recsegtree",
    "body": [
      "template <class node, auto push = nullptr>",
      "struct segtree {",
      "  int n;",
      "  vector<node> tree;",
      "",
      "  segtree(int _n) : n(_n), tree(4 << __lg(_n)) {",
      "    build(1, 0, n - 1);",
      "  }",
      "",
      "  template <typename T>",
      "  segtree(const vector<T> &v) : n(int(v.size())), tree(4 << __lg(n)) {",
      "    build(1, 0, n - 1, v);",
      "  }",
      "",
      "  void pull(int id) {",
      "    tree[id] = tree[id << 1] + tree[id << 1 | 1];",
      "  }",
      "",
      "  void build(int id, int l, int r) {",
      "    if (l == r) {",
      "      return;",
      "    }",
      "    int mid = l + r >> 1;",
      "    build(id << 1, l, mid);",
      "    build(id << 1 | 1, mid + 1, r);",
      "    pull(id);",
      "  }",
      "",
      "  template <typename T>",
      "  void build(int id, int l, int r, const vector<T>& a) {",
      "    if (l == r) {",
      "      tree[id].apply(l, r, a[l]);",
      "      return;",
      "    }",
      "    int mid = l + r >> 1;",
      "    build(id << 1, l, mid, a);",
      "    build(id << 1 | 1, mid + 1, r, a);",
      "    pull(id);",
      "  }",
      "",
      "  node get(int id, int l, int r, int ql, int qr) {",
      "    if (ql <= l && r <= qr) {",
      "      return tree[id];",
      "    }",
      "    if constexpr (push != nullptr) {",
      "      push(tree, id, l, r);",
      "    }",
      "    node res{};",
      "    int mid = l + r >> 1;",
      "    if (qr <= mid) {",
      "      res = get(id << 1, l, mid, ql, qr);",
      "    } else {",
      "      if (ql > mid) {",
      "        res = get(id << 1 | 1, mid + 1, r, ql, qr);",
      "      } else {",
      "        res = get(id << 1, l, mid, ql, qr) + get(id << 1 | 1, mid + 1, r, ql, qr);",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "",
      "  node get(int ql, int qr) {",
      "    assert(0 <= ql && ql <= qr && qr <= n - 1);",
      "    return get(1, 0, n - 1, ql, qr);",
      "  }",
      "",
      "  node get(int p) {",
      "    assert(0 <= p && p <= n - 1);",
      "    return get(1, 0, n - 1, p, p);",
      "  }",
      "",
      "  template <class... Ts>",
      "  void modify(int id, int l, int r, int ql, int qr, const Ts&... v) {",
      "    if (ql <= l && r <= qr) {",
      "      tree[id].apply(l, r, v...);",
      "      return;",
      "    }",
      "    int mid = l + r >> 1;",
      "    if constexpr (push != nullptr) {",
      "      push(tree, id, l, r);",
      "    }",
      "    if (ql <= mid) {",
      "      modify(id << 1, l, mid, ql, qr, v...);",
      "    }",
      "    if (qr > mid) {",
      "      modify(id << 1 | 1, mid + 1, r, ql, qr, v...);",
      "    }",
      "    pull(id);",
      "  }",
      "",
      "  template <class... Ts>",
      "  void modify(int ql, int qr, const Ts&... v) {",
      "    assert(0 <= ql && ql <= qr && qr <= n - 1);",
      "    modify(1, 0, n - 1, ql, qr, v...);",
      "  }",
      "",
      "  int min_left(int id, int l, int r, int ql, int qr, const function<bool(const node&)>& verify) {",
      "    if (qr < l || r < ql) {",
      "      return -1;",
      "    }",
      "    if (ql <= l && r <= qr && !verify(tree[id])) {",
      "      return -1;",
      "    }",
      "    if (l == r) {",
      "      return l;",
      "    }",
      "    if constexpr (push != nullptr) {",
      "      push(tree, id, l, r);",
      "    }",
      "    int mid = l + r >> 1;",
      "    int res = min_left(id << 1, l, mid, ql, qr, verify);",
      "    if (res == -1) {",
      "      res = min_left(id << 1 | 1, mid + 1, r, ql, qr, verify);",
      "    }",
      "    return res;",
      "  }",
      "",
      "  int min_left(int ql, int qr, const function<bool(const node&)>& verify) {",
      "    return min_left(1, 0, n - 1, ql, qr, verify);",
      "  }",
      "",
      "  int max_right(int id, int l, int r, int ql, int qr, const function<bool(const node&)>& verify) {",
      "    if (qr < l || r < ql) {",
      "      return -1;",
      "    }",
      "    if (ql <= l && r <= qr && !verify(tree[id])) {",
      "      return -1;",
      "    }",
      "    if (l == r) {",
      "      return l;",
      "    }",
      "    if constexpr (push != nullptr) {",
      "      push(tree, id, l, r);",
      "    }",
      "    int mid = l + r >> 1;",
      "    int res = max_right(id << 1 | 1, mid + 1, r, ql, qr, verify);",
      "    if (res == -1) {",
      "      res = max_right(id << 1, l, mid, ql, qr, verify);",
      "    }",
      "    return res;",
      "  }",
      "",
      "  int max_right(int ql, int qr, const function<bool(const node&)>& verify) {",
      "    return max_right(1, 0, n - 1, ql, qr, verify);",
      "  }",
      "};",
      "",
      "struct node {",
      "  int64_t sum = 0;",
      "  int64_t add = 0;",
      "",
      "  void apply(int l, int r, int64_t v) {",
      "    sum += v * (r - l + 1);",
      "    add += v;",
      "  }",
      "};",
      "",
      "node operator+(const node& a, const node& b) {",
      "  node res{};",
      "  res.sum = a.sum + b.sum;",
      "  return res;",
      "}",
      "",
      "void push(vector<node>& tree, int id, int l, int r) {",
      "  int mid = l + r >> 1;",
      "  if (tree[id].add != 0) {",
      "    tree[id << 1].apply(l, mid, tree[id].add);",
      "    tree[id << 1 | 1].apply(mid + 1, r, tree[id].add);",
      "    tree[id].add = 0;",
      "  }",
      "}",
      ""
    ],
    "description": "recsegtree"
  },
  "rng": {
    "prefix": "rng",
    "body": [
      "std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());",
      ""
    ],
    "description": "rng"
  },
  "scc": {
    "prefix": "scc",
    "body": [
      "template <typename T>",
      "class scc {",
      " public:",
      "  const std::vector<std::vector<T>>& g;",
      "  std::vector<int> stk, pos, bel;",
      "  std::vector<std::vector<int>> res;",
      "",
      "  scc(const std::vector<std::vector<T>>& t) : g(t), pos(t.size(), -1), bel(t.size(), -1) {",
      "    run();",
      "  }",
      "",
      "  int dfs(int u) {",
      "    int low = pos[u] = stk.size();",
      "    stk.push_back(u);",
      "    for (const auto j : g[u]) {",
      "      int v;",
      "      if constexpr (std::is_integral_v<std::decay_t<decltype(j)>>) {",
      "        v = j;",
      "      } else {",
      "        v = std::get<0>(j);",
      "      }",
      "      if (bel[v] == -1) {",
      "        low = std::min(low, pos[v] == -1 ? dfs(v) : pos[v]);",
      "      }",
      "    }",
      "    if (pos[u] == low) {",
      "      res.emplace_back(stk.begin() + low, stk.end());",
      "      for (const int v : res.back()) {",
      "        bel[v] = int(res.size()) - 1;",
      "      }",
      "      stk.resize(low);",
      "    }",
      "    return low;",
      "  }",
      "",
      "  void run() {",
      "    for (int i = 0; i < g.size(); i++) {",
      "      if (pos[i] == -1) {",
      "        dfs(i);",
      "      }",
      "    }",
      "    std::swap(pos, bel);",
      "  }",
      "};",
      ""
    ],
    "description": "scc"
  },
  "segtree": {
    "prefix": "segtree",
    "body": [
      "template <class Info, class Tag = std::monostate>",
      "class SegmentTree {",
      " public:",
      "  static constexpr bool lazy = !std::is_same_v<Tag, std::monostate>;",
      "",
      "  explicit SegmentTree(int _n) : n(_n) {",
      "    sz = 1 << std::__lg(n);",
      "    if (sz < n) sz <<= 1;",
      "    ht = __builtin_ctz(sz);",
      "    info = std::vector<Info>(sz * 2);",
      "    if constexpr (lazy) tag = std::vector<Tag>(sz * 2);",
      "  }",
      "",
      "  template <typename T>",
      "  explicit SegmentTree(const std::vector<T>& a) : SegmentTree(int(a.size())) {",
      "    for (int i = 0; i < n; i++) info[i + sz] = Info{a[i]};",
      "    for (int i = (sz + n - 1) >> 1; i > 0; i--) pull(i);",
      "  }",
      "",
      "  template <class T>",
      "  void modify(int p, const T& t) {",
      "    assert(0 <= p && p < n);",
      "    p += sz;",
      "    for (int i = ht; i > 0; i--) push(p >> i);",
      "    if constexpr (lazy && std::is_same_v<T, Tag>) {",
      "      info[p].apply(t);",
      "    } else {",
      "      static_assert(std::is_same_v<T, Info>);",
      "      info[p] = t;",
      "    }",
      "    for (int i = 1; i <= ht; i++) pull(p >> i);",
      "  }",
      "",
      "  Info get(int p) {",
      "    assert(0 <= p && p < n);",
      "    p += sz;",
      "    for (int i = ht; i > 0; i--) push(p >> i);",
      "    return info[p];",
      "  }",
      "",
      "  template <class T>",
      "  void modify(int l, int r, const T& t) {",
      "    static_assert(std::is_same_v<T, Tag>);",
      "    assert(0 <= l && l <= r && r <= n);",
      "    if (l == r) return;",
      "    l += sz; r += sz;",
      "    for (int i = ht; i > 0; i--) {",
      "      if ((l >> i << i) != l) push(l >> i);",
      "      if ((r >> i << i) != r) push(r >> i);",
      "    }",
      "    for (int ll = l, rr = r; ll < rr; ll >>= 1, rr >>= 1) {",
      "      if (ll & 1) apply(ll++, t);",
      "      if (rr & 1) apply(--rr, t);",
      "    }",
      "    for (int i = 1; i <= ht; i++) {",
      "      if ((l >> i << i) != l) pull(l >> i);",
      "      if ((r >> i << i) != r) pull(r >> i);",
      "    }",
      "  };",
      "",
      "  Info get(int l, int r) {",
      "    if (l + 1 == r) return get(l);",
      "    assert(0 <= l && l <= r && r <= n);",
      "    if (l == r) return Info{};",
      "    l += sz; r += sz;",
      "    for (int i = ht; i > 0; i--) {",
      "      if ((l >> i << i) != l) push(l >> i);",
      "      if ((r >> i << i) != r) push(r >> i);",
      "    }",
      "    Info lres{}, rres{};",
      "    for (; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) lres = lres + info[l++];",
      "      if (r & 1) rres = info[--r] + rres;",
      "    }",
      "    return lres + rres;",
      "  }",
      "",
      "  static constexpr std::array<int, 2> from_l_to_r {0, 1};",
      "  static constexpr std::array<int, 2> from_r_to_l {1, 0};",
      "",
      "  template <class F>",
      "  int dive(int id, const std::array<int, 2> mode, F f) {",
      "    while (id < sz) {",
      "      push(id);",
      "      id <<= 1;",
      "      for (int i : mode) {",
      "        if (f(info[id + i])) {",
      "          id += i;",
      "          break;",
      "        }",
      "      }",
      "    }",
      "    return id - sz;",
      "  }",
      "",
      "  template <class F>",
      "  int find_first(int l, int r, F f) {",
      "    assert(0 <= l && l < r && r <= n);",
      "    l += sz; r += sz;",
      "    for (int i = ht; i > 0; i--) {",
      "      if ((l >> i << i) != l) push(l >> i);",
      "      if ((r >> i << i) != r) push(r >> i);",
      "    }",
      "    int l_cur = ht;",
      "    while ((r >> (ht - l_cur)) != l) {",
      "      while ((l & 1) == 0 && (l >> 1) != (r >> (ht - l_cur + 1))) {",
      "        l >>= 1;",
      "        l_cur--;",
      "      }",
      "      if (f(info[l])) {",
      "        int ans = dive(l, from_l_to_r, f);",
      "        return ans >= r - sz ? -1 : ans;",
      "      }",
      "      l++;",
      "    }",
      "    if (r == sz * 2 || !f(info[l])) return -1;",
      "    int ans = dive(l, from_l_to_r, f);",
      "    return ans >= r - sz ? -1 : ans;",
      "  }",
      "",
      "  template <class F>",
      "  int find_last(int l, int r, F f) {",
      "    assert(0 <= l && l < r && r <= n);",
      "    int old_r = r;",
      "    l += sz; r += sz;",
      "    for (int i = ht; i > 0; i--) {",
      "      if ((l >> i << i) != l) push(l >> i);",
      "      if ((r >> i << i) != r) push(r >> i);",
      "    }",
      "    l--; r--;",
      "    int r_cur = ht;",
      "    while ((l >> (ht - r_cur)) != r) {",
      "      while ((r & 1) == 1 && (r >> 1) != (l >> (ht - r_cur + 1))) {",
      "        r >>= 1;",
      "        r_cur--;",
      "      }",
      "      if (f(info[r])) {",
      "        int ans = dive(r, from_r_to_l, f);",
      "        return ans <= l - sz ? -1 : ans;",
      "      }",
      "      r--;",
      "    }",
      "    if (l == sz - 1 || !f(info[r])) return -1;",
      "    int ans = dive(r, from_r_to_l, f);",
      "    return ans <= l - sz ? -1 : ans;",
      "  }",
      "",
      "  template <class G>",
      "  int max_right(int l, G g) {",
      "    assert(0 <= l && l <= n);",
      "    assert(g(Info{}));",
      "    if (l == n) return n;",
      "    l += sz;",
      "    for (int i = ht; i >= 1; i--) push(l >> i);",
      "    Info sm = Info{};",
      "    do {",
      "      while (l % 2 == 0) l >>= 1;",
      "      if (!g(sm + info[l])) {",
      "        while (l < sz) {",
      "          push(l);",
      "          l = (2 * l);",
      "          if (g(sm + info[l])) {",
      "            sm = sm + info[l];",
      "            l++;",
      "          }",
      "        }",
      "        return l - sz;",
      "      }",
      "      sm = sm + info[l];",
      "      l++;",
      "    } while ((l & -l) != l);",
      "    return n;",
      "  }",
      "",
      "  template <class G>",
      "  int min_left(int r, G g) {",
      "    assert(0 <= r && r <= n);",
      "    assert(g(Info{}));",
      "    if (r == 0) return 0;",
      "    r += sz;",
      "    for (int i = ht; i >= 1; i--) push((r - 1) >> i);",
      "    Info sm = Info{};",
      "    do {",
      "      r--;",
      "      while (r > 1 && (r % 2)) r >>= 1;",
      "      if (!g(info[r] + sm)) {",
      "        while (r < sz) {",
      "          push(r);",
      "          r = (2 * r + 1);",
      "          if (g(info[r] + sm)) {",
      "            sm = info[r] + sm;",
      "            r--;",
      "          }",
      "        }",
      "        return r + 1 - sz;",
      "      }",
      "      sm = info[r] + sm;",
      "    } while ((r & -r) != r);",
      "    return 0;",
      "  }",
      " private:",
      "  int n, sz, ht;",
      "  std::vector<Info> info;",
      "  std::vector<Tag> tag;",
      "",
      "  void pull(int id) {",
      "    info[id] = info[id << 1] + info[id << 1 | 1];",
      "  }",
      "",
      "  void apply(int id, const Tag& t) {",
      "    if constexpr (lazy) {",
      "      tag[id].apply(t);",
      "      info[id].apply(t);",
      "    }",
      "  }",
      "",
      "  void push(int id) {",
      "    if constexpr (lazy) {",
      "      if (tag[id].empty()) return;",
      "      apply(id << 1, tag[id]);",
      "      apply(id << 1 | 1, tag[id]);",
      "      tag[id] = Tag{};",
      "    }",
      "  }",
      "};",
      "",
      "struct Tag {",
      "  int64_t add = 0;",
      "",
      "  void apply(const Tag& v) {",
      "    add += v.add;",
      "  }",
      "",
      "  bool empty() {",
      "    return add == 0;",
      "  }",
      "};",
      "",
      "struct Info {",
      "  int64_t ans = 0;",
      "  int len = 0;",
      "",
      "  void apply(const Tag& v) {",
      "    ans += v.add * len;",
      "  }",
      "};",
      "",
      "Info operator+(const Info& a, const Info& b) {",
      "  return Info{",
      "    a.ans + b.ans,",
      "    a.len + b.len,",
      "  };",
      "}",
      "",
      "using segtree = SegmentTree<Info, Tag>;",
      ""
    ],
    "description": "segtree"
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "std::vector<int> least, primes;",
      "void sieve(int n) {",
      "  least.assign(n + 1, 0);",
      "  primes.clear();",
      "  for (int i = 2; i <= n; i++) {",
      "    if (least[i] == 0) {",
      "      least[i] = i;",
      "      primes.push_back(i);",
      "    }",
      "    for (auto p : primes) {",
      "      if (p > least[i] || i * p > n) break;",
      "      least[i * p] = p;",
      "    }",
      "  }",
      "}",
      ""
    ],
    "description": "sieve"
  },
  "sparsetable": {
    "prefix": "sparsetable",
    "body": [
      "template <typename T, class F>",
      "class ST {",
      " public:",
      "  int n;",
      "  vector<vector<T>> mat;",
      "  F func;",
      "",
      "  ST(const vector<T>& a, const F& f) : func(f) {",
      "    n = static_cast<int>(a.size());",
      "    int max_log = 32 - __builtin_clz(n);",
      "    mat.resize(max_log);",
      "    mat[0] = a;",
      "    for (int j = 1; j < max_log; j++) {",
      "      mat[j].resize(n - (1 << j) + 1);",
      "      for (int i = 0; i <= n - (1 << j); i++) {",
      "        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);",
      "      }",
      "    }",
      "  }",
      "",
      "  T get(int from, int to) const {",
      "    assert(0 <= from && from <= to && to <= n - 1);",
      "    int lg = 31 ^ __builtin_clz(to - from + 1);",
      "    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);",
      "  }",
      "};",
      ""
    ],
    "description": "sparsetable"
  },
  "split": {
    "prefix": "split",
    "body": [
      "vector<string> split(string_view s, char separator) {",
      "  vector<string> ret;",
      "  string t;",
      "  for (auto c : s) {",
      "    if (c == separator) {",
      "      if (!t.empty()) ret.push_back(t);",
      "      t.clear();",
      "    } else {",
      "      t.push_back(c);",
      "    }",
      "  }",
      "  if (!t.empty()) ret.push_back(t);",
      "  return ret;",
      "}",
      ""
    ],
    "description": "split"
  },
  "suffix_array": {
    "prefix": "suffix_array",
    "body": [
      "template <typename T>",
      "std::vector<int> suffix_array(const T& s) {",
      "  int n = s.size();",
      "  std::vector<int> sa(n), rk(n), cnt(n), rk_by_second(n);",
      "  if constexpr (std::is_same<T, string>::value) {",
      "    std::vector<int> cnt(128);",
      "    for (auto i : s) {",
      "      cnt[i]++;",
      "    }",
      "    std::partial_sum(cnt.begin(), cnt.end(), cnt.begin());",
      "    for (int i = n - 1; i >= 0; i--) {",
      "      sa[--cnt[s[i]]] = i;",
      "    }",
      "  } else {",
      "    std::iota(sa.begin(), sa.end(), 0);",
      "    std::sort(sa.begin(), sa.end(), [&](auto i, auto j) { return s[i] < s[j]; });",
      "  }",
      "  rk[sa[0]] = 0;",
      "  for (int i = 1; i < n; i++) {",
      "    rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);",
      "  }",
      "  for (int step = 1; rk[sa[n - 1]] < n - 1; step <<= 1) {",
      "    rk_by_second.clear();",
      "    for (int i = n - step; i < n; i++) {",
      "      rk_by_second.push_back(i);",
      "    }",
      "    for (auto i : sa) {",
      "      if (i >= step) {",
      "        rk_by_second.push_back(i - step);",
      "      }",
      "    }",
      "    std::fill(cnt.begin(), cnt.end(), 0);",
      "    for (int i = 0; i < n; i++) {",
      "      cnt[rk[i]]++;",
      "    }",
      "    std::partial_sum(cnt.begin(), cnt.end(), cnt.begin());",
      "    for (int i = n - 1; i >= 0; i--) {",
      "      int t = rk_by_second[i];",
      "      sa[--cnt[rk[t]]] = t;",
      "    }",
      "    std::swap(rk, rk_by_second);",
      "    rk[sa[0]] = 0;",
      "    for (int i = 1; i < n; i++) {",
      "      rk[sa[i]] = rk[sa[i - 1]]",
      "       + (rk_by_second[sa[i - 1]] < rk_by_second[sa[i]]",
      "          || sa[i - 1] + step == n",
      "          || rk_by_second[sa[i - 1] + step] < rk_by_second[sa[i] + step]);",
      "    }",
      "  }",
      "  return sa;",
      "}",
      "",
      "template <typename T>",
      "std::vector<int> build_lcp(const T& s, const std::vector<int>& sa) {",
      "  int n = s.size();",
      "  std::vector<int> rk(n);",
      "  for (int i = 0; i < n; i++) {",
      "    rk[sa[i]] = i;",
      "  }",
      "  std::vector<int> lcp(std::max(n - 1, 0));",
      "  for (int i = 0, k = 0; i < n; i++) {",
      "    if (k > 0) k--;",
      "    if (rk[i] == 0) continue;",
      "    int j = sa[rk[i] - 1];",
      "    while (j + k != n && i + k != n && s[j + k] == s[i + k]) k++;",
      "    lcp[rk[i] - 1] = k;",
      "  }",
      "  return lcp;",
      "}",
      ""
    ],
    "description": "suffix_array"
  },
  "topsort": {
    "prefix": "topsort",
    "body": [
      "template <typename T>",
      "std::vector<int> topsort(const std::vector<std::vector<T>>& g) {",
      "  int n = g.size();",
      "  std::vector<int> deg(n);",
      "  std::vector<int> q;",
      "  for (const auto& x : g) {",
      "    for (const auto y : x) {",
      "      int v;",
      "      if constexpr (std::integral<T>) {",
      "        v = y;",
      "      } else {",
      "        v = std::get<0>(y);",
      "      }",
      "      deg[v]++;",
      "    }",
      "  }",
      "  for (int i = 0; i < n; i++) {",
      "    if (deg[i] == 0) {",
      "      q.push_back(i);",
      "    }",
      "  }",
      "  for (int i = 0; i < q.size(); i++) {",
      "    for (const auto j : g[q[i]]) {",
      "      int v;",
      "      if constexpr (std::integral<T>) {",
      "        v = j;",
      "      } else {",
      "        v = std::get<0>(j);",
      "      }",
      "      if (--deg[v] == 0) {",
      "        q.push_back(v);",
      "      }",
      "    }",
      "  }",
      "  if (int(q.size()) != n) return {};",
      "  return q;",
      "}",
      ""
    ],
    "description": "topsort"
  },
  "twosat": {
    "prefix": "twosat",
    "body": [
      "class twosat {",
      " public:",
      "  int n;",
      "  bool ok = true;",
      "  std::vector<int> ans;",
      "  std::vector<std::vector<int>> g;",
      "",
      "  explicit twosat(int _n) : n(_n), g(2 * _n), ans(n) {}",
      "",
      "  void add(int u, int val1, int v, int val2) {",
      "    g[2 * u + !val1].push_back(2 * v + val2);",
      "    g[2 * v + !val2].push_back(2 * u + val1);",
      "  }",
      "",
      "  void build() {",
      "    scc cc(g);",
      "    for (int i = 0; i < n; i++) {",
      "      if (cc.pos[2 * i] == cc.pos[2 * i + 1]) {",
      "        ok = false;",
      "      }",
      "      ans[i] = cc.pos[2 * i] > cc.pos[2 * i + 1];",
      "    }",
      "  }",
      "};",
      ""
    ],
    "description": "twosat"
  },
  "vcc": {
    "prefix": "vcc",
    "body": [
      "template <typename T>",
      "struct vcc {",
      "  const vector<vector<T>>& g;",
      "  vector<int> pos, stk;",
      "  vector<vector<int>> res;",
      "  vector<bool> cut;",
      "",
      "  vcc(const vector<vector<T>>& t): g(t), pos(t.size(), -1), cut(t.size()) {",
      "    run();",
      "  }",
      "",
      "  int dfs(int u, int p) {",
      "    int low = pos[u] = stk.size(), son = 0;",
      "    stk.push_back(u);",
      "    for (const auto j : g[u]) {",
      "      int v;",
      "      if constexpr (std::is_integral_v<std::decay_t<decltype(j)>>) {",
      "        v = j;",
      "      } else {",
      "        v = std::get<0>(j);",
      "      }",
      "      if (v != p) {",
      "        if (pos[v] != -1) {",
      "          low = min(low, pos[v]);",
      "        } else {",
      "          int cur = stk.size(), low_v = dfs(v, u);",
      "          low = min(low, low_v);",
      "          if (low_v >= pos[u] && (p != -1 || son++)) {",
      "            cut[u] = true;",
      "            res.emplace_back(stk.begin() + cur, stk.end());",
      "            res.back().push_back(u);",
      "            stk.resize(cur);",
      "          }",
      "        }",
      "      }",
      "    }",
      "    return low;",
      "  }",
      "",
      "  void run() {",
      "    for (int i = 0; i < g.size(); i++) {",
      "      if (pos[i] == -1) {",
      "        dfs(i, -1);",
      "        res.emplace_back(move(stk));",
      "      }",
      "    }",
      "  }",
      "};",
      ""
    ],
    "description": "vcc"
  },
  "z_function": {
    "prefix": "z_function",
    "body": [
      "template <class T>",
      "std::vector<int> z_function(const T &s) {",
      "  int n = s.size();",
      "  std::vector<int> z(n, n);",
      "  for (int i = 1, l = 0, r = 0; i < n; i++) {",
      "    z[i] = std::max(0, std::min(z[i - l], r - i + 1));",
      "    if (i > r || z[i - l] == r - i + 1) {",
      "      if (i > r) r = i - 1;",
      "      while (r + 1 < n && s[r + 1] == s[r - i + 1]) {",
      "        r++;",
      "      }",
      "      l = i;",
      "      z[i] = r - i + 1;",
      "    }",
      "  }",
      "  return z;",
      "}",
      ""
    ],
    "description": "z_function"
  }
}